#!/usr/bin/env python3
"""
Auto-generated MCP stdio server from OpenAPI.
Generated by: openapi-to-mcp.py
"""

from __future__ import annotations

import base64
import json
import os
import sys
import urllib.error
import urllib.parse
import urllib.request
from typing import Any, Dict, Iterable, List, Optional, Tuple

SERVER_NAME = 'todo_mini_mcp'
SERVER_VERSION = "0.1.0"
BASE_URL = 'https://api.todo-mini.example.com'
GENERATOR_META = {'name': 'openapi-to-mcp.py', 'generatedAt': '2026-02-16T05:50:16.748880+00:00'}
OPENAPI_SOURCE = 'skills/openapi-tool-scaffold/examples/todo-mini-openapi.yaml'

TOOLS: List[Dict[str, Any]] = [{'name': 'listtodos',
  'description': 'List todo items',
  'inputSchema': {'type': 'object',
                  'properties': {'status': {'type': 'string',
                                            'enum': ['open', 'done'],
                                            'description': 'Filter by status | OpenAPI parameter '
                                                           '(query: status)'}},
                  'additionalProperties': False}},
 {'name': 'createtodo',
  'description': 'Create a todo item',
  'inputSchema': {'type': 'object',
                  'properties': {'body': {'type': 'object',
                                          'properties': {'title': {'type': 'string'},
                                                         'done': {'type': 'boolean'}},
                                          'required': ['title']}},
                  'additionalProperties': False,
                  'required': ['body']}},
 {'name': 'gettodobyid',
  'description': 'Get one todo item',
  'inputSchema': {'type': 'object',
                  'properties': {'todoid': {'type': 'integer',
                                            'description': 'OpenAPI parameter (path: todoId)'}},
                  'additionalProperties': False,
                  'required': ['todoid']}},
 {'name': 'getprofile',
  'description': 'Get user profile',
  'inputSchema': {'type': 'object', 'properties': {}, 'additionalProperties': False}}]
TOOL_RUNTIME: Dict[str, Dict[str, Any]] = {'listtodos': {'method': 'GET',
               'path': '/todos',
               'parameters': [{'arg': 'status',
                               'name': 'status',
                               'in': 'query',
                               'required': False}],
               'body_arg': None,
               'body_content_type': None,
               'security': [{'BearerAuth': []}, {'ApiKeyAuth': []}]},
 'createtodo': {'method': 'POST',
                'path': '/todos',
                'parameters': [],
                'body_arg': 'body',
                'body_content_type': 'application/json',
                'security': [{'BearerAuth': []}, {'ApiKeyAuth': []}]},
 'gettodobyid': {'method': 'GET',
                 'path': '/todos/{todoId}',
                 'parameters': [{'arg': 'todoid',
                                 'name': 'todoId',
                                 'in': 'path',
                                 'required': True}],
                 'body_arg': None,
                 'body_content_type': None,
                 'security': [{'BearerAuth': []}, {'ApiKeyAuth': []}]},
 'getprofile': {'method': 'GET',
                'path': '/profile',
                'parameters': [],
                'body_arg': None,
                'body_content_type': None,
                'security': [{'OAuth2Auth': ['profile.read']}]}}
SECURITY_SCHEMES: Dict[str, Dict[str, Any]] = {'BearerAuth': {'type': 'http', 'scheme': 'bearer', 'bearerFormat': 'JWT'},
 'ApiKeyAuth': {'type': 'apiKey', 'in': 'header', 'name': 'X-API-Key'},
 'OAuth2Auth': {'type': 'oauth2',
                'flows': {'authorizationCode': {'authorizationUrl': 'https://auth.todo-mini.example.com/oauth/authorize',
                                                'tokenUrl': 'https://auth.todo-mini.example.com/oauth/token',
                                                'scopes': {'profile.read': 'Read profile'}}}}}

SUPPORTED_PROTOCOLS = ["2025-06-18", "2025-03-26", "2024-11-05"]
USE_CONTENT_LENGTH = os.getenv("MCP_USE_CONTENT_LENGTH", "0") == "1"
MAX_RESPONSE_CHARS = int(os.getenv("MCP_MAX_RESPONSE_CHARS", "12000"))


def _log(msg: str) -> None:
    sys.stderr.write(f"[{SERVER_NAME}] {msg}\n")
    sys.stderr.flush()


def _compact_json(obj: Any) -> str:
    return json.dumps(obj, ensure_ascii=False, separators=(",", ":"))


def _pretty_json(obj: Any) -> str:
    return json.dumps(obj, ensure_ascii=False, indent=2)


def _truncate_text(text: str, max_chars: int = MAX_RESPONSE_CHARS) -> str:
    if len(text) <= max_chars:
        return text
    return text[: max_chars - 48] + "\n... [truncated] ..."


def _send_message(message: Dict[str, Any]) -> None:
    payload = _compact_json(message).encode("utf-8")
    if USE_CONTENT_LENGTH:
        header = f"Content-Length: {len(payload)}\r\n\r\n".encode("utf-8")
        sys.stdout.buffer.write(header)
        sys.stdout.buffer.write(payload)
    else:
        sys.stdout.buffer.write(payload + b"\n")
    sys.stdout.buffer.flush()


def _send_result(request_id: Any, result: Dict[str, Any]) -> None:
    _send_message({"jsonrpc": "2.0", "id": request_id, "result": result})


def _send_error(request_id: Any, code: int, message: str, data: Optional[Any] = None) -> None:
    error_obj: Dict[str, Any] = {"code": code, "message": message}
    if data is not None:
        error_obj["data"] = data
    _send_message({"jsonrpc": "2.0", "id": request_id, "error": error_obj})


def _iter_messages() -> Iterable[Dict[str, Any]]:
    stdin = sys.stdin.buffer

    while True:
        line = stdin.readline()
        if not line:
            break

        stripped = line.strip()
        if not stripped:
            continue

        if stripped.lower().startswith(b"content-length:"):
            try:
                length = int(stripped.split(b":", 1)[1].strip())
            except (IndexError, ValueError):
                _log("Invalid Content-Length header")
                continue

            while True:
                header_line = stdin.readline()
                if not header_line:
                    return
                if header_line in (b"\r\n", b"\n"):
                    break

            body = stdin.read(length)
            if not body:
                return
            try:
                msg = json.loads(body.decode("utf-8"))
            except json.JSONDecodeError as exc:
                _log(f"Invalid JSON payload (content-length mode): {exc}")
                continue
            if isinstance(msg, dict):
                yield msg
            continue

        try:
            msg = json.loads(stripped.decode("utf-8"))
        except json.JSONDecodeError as exc:
            _log(f"Invalid JSON line: {exc}")
            continue

        if isinstance(msg, dict):
            yield msg


def _env_suffix(name: str) -> str:
    return "".join(ch if ch.isalnum() else "_" for ch in name.upper())


def _apply_single_security_scheme(
    scheme_name: str,
    scopes: List[str],
    scheme: Dict[str, Any],
    headers: Dict[str, str],
    query: Dict[str, Any],
    cookies: Dict[str, str],
) -> Tuple[bool, str]:
    _ = scopes
    suffix = _env_suffix(scheme_name)
    scheme_type = (scheme.get("type") or "").lower()

    if scheme_type == "http":
        http_scheme = (scheme.get("scheme") or "").lower()
        if http_scheme == "bearer":
            token = os.getenv(f"BEARER_TOKEN_{suffix}") or os.getenv("BEARER_TOKEN")
            if not token:
                return False, (
                    f"Missing bearer token for security scheme '{scheme_name}'. "
                    f"Set BEARER_TOKEN_{suffix} or BEARER_TOKEN."
                )
            headers["Authorization"] = f"Bearer {token}"
            return True, ""
        if http_scheme == "basic":
            username = os.getenv(f"BASIC_USERNAME_{suffix}") or os.getenv("BASIC_USERNAME")
            password = os.getenv(f"BASIC_PASSWORD_{suffix}") or os.getenv("BASIC_PASSWORD")
            if username is None or password is None:
                return False, (
                    f"Missing basic auth credentials for '{scheme_name}'. "
                    f"Set BASIC_USERNAME_{suffix}/BASIC_PASSWORD_{suffix} "
                    "or BASIC_USERNAME/BASIC_PASSWORD."
                )
            raw = f"{username}:{password}".encode("utf-8")
            headers["Authorization"] = "Basic " + base64.b64encode(raw).decode("ascii")
            return True, ""

        return False, f"Unsupported HTTP auth scheme '{http_scheme}' for '{scheme_name}'."

    if scheme_type == "apikey":
        key_value = os.getenv(f"API_KEY_{suffix}") or os.getenv("API_KEY")
        if not key_value:
            return False, (
                f"Missing API key for security scheme '{scheme_name}'. "
                f"Set API_KEY_{suffix} or API_KEY."
            )

        in_location = (scheme.get("in") or "header").lower()
        key_name = scheme.get("name") or scheme_name
        if in_location == "header":
            headers[key_name] = key_value
        elif in_location == "query":
            query[key_name] = key_value
        elif in_location == "cookie":
            cookies[key_name] = key_value
        else:
            return False, (
                f"Unsupported API key location '{in_location}' for scheme '{scheme_name}'."
            )
        return True, ""

    if scheme_type in {"oauth2", "openidconnect"}:
        token = os.getenv(f"OAUTH_ACCESS_TOKEN_{suffix}") or os.getenv("OAUTH_ACCESS_TOKEN")
        if not token:
            scope_hint = f" required scopes={scopes}" if scopes else ""
            return False, (
                f"OAuth stub: missing access token for '{scheme_name}'."
                f" Set OAUTH_ACCESS_TOKEN_{suffix} or OAUTH_ACCESS_TOKEN.{scope_hint}"
            )
        headers["Authorization"] = f"Bearer {token}"
        return True, ""

    if scheme_type == "none" or not scheme_type:
        return True, ""

    return False, f"Unsupported security scheme type '{scheme_type}' for '{scheme_name}'."


def _apply_security_requirements(
    requirements: List[Dict[str, List[str]]],
    headers: Dict[str, str],
    query: Dict[str, Any],
    cookies: Dict[str, str],
) -> Optional[str]:
    if not requirements:
        return None

    last_error = "No security requirement matched available credentials."

    # OpenAPI security: list entries are OR. Inside each entry, schemes are AND.
    for requirement_entry in requirements:
        trial_headers = dict(headers)
        trial_query = dict(query)
        trial_cookies = dict(cookies)
        ok = True

        for scheme_name, scopes in requirement_entry.items():
            scheme = SECURITY_SCHEMES.get(scheme_name)
            if scheme is None:
                ok = False
                last_error = f"Referenced security scheme '{scheme_name}' not found in components.securitySchemes."
                break
            success, message = _apply_single_security_scheme(
                scheme_name,
                scopes if isinstance(scopes, list) else [],
                scheme,
                trial_headers,
                trial_query,
                trial_cookies,
            )
            if not success:
                ok = False
                last_error = message
                break

        if ok:
            headers.clear()
            headers.update(trial_headers)
            query.clear()
            query.update(trial_query)
            cookies.clear()
            cookies.update(trial_cookies)
            return None

    return last_error


def _tool_error(message: str) -> Dict[str, Any]:
    return {
        "content": [{"type": "text", "text": message}],
        "isError": True,
    }


def _invoke_tool(name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
    runtime = TOOL_RUNTIME.get(name)
    if not runtime:
        return _tool_error(f"Unknown tool: {name}")

    method = (runtime.get("method") or "get").upper()
    path_template = runtime.get("path") or "/"
    params = runtime.get("parameters") or []

    headers: Dict[str, str] = {"Accept": "application/json"}
    query: Dict[str, Any] = {}
    cookies: Dict[str, str] = {}
    path = path_template

    for param in params:
        arg_name = param.get("arg")
        source_name = param.get("name")
        location = (param.get("in") or "query").lower()
        required = bool(param.get("required"))

        value = arguments.get(arg_name)
        if value is None:
            if required:
                return _tool_error(f"Missing required argument: {arg_name}")
            continue

        if location == "path":
            encoded = urllib.parse.quote(str(value), safe="")
            path = path.replace("{" + str(source_name) + "}", encoded)
        elif location == "query":
            query[source_name] = value
        elif location == "header":
            headers[source_name] = str(value)
        elif location == "cookie":
            cookies[source_name] = str(value)

    body_arg = runtime.get("body_arg")
    body_content_type = runtime.get("body_content_type") or "application/json"
    body_data: Optional[bytes] = None
    if body_arg:
        body_value = arguments.get(body_arg)
        if body_value is not None:
            if isinstance(body_value, (dict, list)):
                body_data = json.dumps(body_value, ensure_ascii=False).encode("utf-8")
                headers["Content-Type"] = body_content_type
            elif isinstance(body_value, str):
                body_data = body_value.encode("utf-8")
                headers.setdefault("Content-Type", body_content_type)
            else:
                body_data = json.dumps(body_value, ensure_ascii=False).encode("utf-8")
                headers["Content-Type"] = body_content_type

    security = runtime.get("security") or []
    auth_error = _apply_security_requirements(security, headers, query, cookies)
    if auth_error:
        return _tool_error(auth_error)

    if cookies:
        headers["Cookie"] = "; ".join(f"{k}={v}" for k, v in cookies.items())

    url = BASE_URL.rstrip("/") + path
    if query:
        query_string = urllib.parse.urlencode(query, doseq=True)
        url += ("&" if "?" in url else "?") + query_string

    timeout = float(os.getenv("API_TIMEOUT_SECONDS", "30"))
    req = urllib.request.Request(url=url, data=body_data, headers=headers, method=method)

    status_code: int
    response_body: bytes
    response_headers: Dict[str, str]

    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            status_code = int(getattr(resp, "status", 200))
            response_body = resp.read()
            response_headers = {k: v for (k, v) in resp.headers.items()}
    except urllib.error.HTTPError as exc:
        status_code = int(exc.code)
        response_body = exc.read() if hasattr(exc, "read") else b""
        response_headers = dict(getattr(exc, "headers", {}) or {})
    except Exception as exc:
        return _tool_error(f"HTTP request failed: {exc}")

    raw_text = response_body.decode("utf-8", errors="replace")
    content_type = (response_headers.get("Content-Type") or "").lower()

    parsed: Any = None
    if "json" in content_type and raw_text.strip():
        try:
            parsed = json.loads(raw_text)
        except json.JSONDecodeError:
            parsed = None

    payload: Dict[str, Any] = {
        "status": status_code,
        "method": method,
        "url": url,
    }
    if parsed is not None:
        payload["data"] = parsed
    else:
        payload["data"] = _truncate_text(raw_text)

    text = _pretty_json(payload)
    result: Dict[str, Any] = {
        "content": [{"type": "text", "text": _truncate_text(text)}],
        "isError": status_code >= 400,
    }

    if parsed is not None and isinstance(parsed, (dict, list)):
        result["structuredContent"] = {
            "status": status_code,
            "data": parsed,
        }

    return result


def _handle_request(message: Dict[str, Any]) -> None:
    request_id = message.get("id")
    method = message.get("method")
    params = message.get("params") or {}

    # Ignore responses from client side.
    if method is None:
        return

    if method == "initialize":
        requested = params.get("protocolVersion")
        if requested in SUPPORTED_PROTOCOLS:
            negotiated = requested
        else:
            negotiated = SUPPORTED_PROTOCOLS[0]

        result = {
            "protocolVersion": negotiated,
            "capabilities": {
                "tools": {
                    "listChanged": False,
                }
            },
            "serverInfo": {
                "name": SERVER_NAME,
                "version": SERVER_VERSION,
            },
            "instructions": (
                "Auto-generated OpenAPI bridge server. "
                "Set auth credentials via environment variables as needed."
            ),
        }
        _send_result(request_id, result)
        return

    if method == "notifications/initialized":
        return

    if method in {"ping", "health/check"}:
        _send_result(request_id, {})
        return

    if method == "tools/list":
        _send_result(request_id, {"tools": TOOLS})
        return

    if method == "tools/call":
        name = params.get("name")
        if not isinstance(name, str) or name not in TOOL_RUNTIME:
            _send_error(request_id, -32602, f"Unknown tool: {name}")
            return
        arguments = params.get("arguments")
        if arguments is None:
            arguments = {}
        if not isinstance(arguments, dict):
            _send_error(request_id, -32602, "tools/call.arguments must be an object")
            return

        result = _invoke_tool(name, arguments)
        _send_result(request_id, result)
        return

    _send_error(request_id, -32601, f"Method not found: {method}")


def main() -> None:
    _log(
        f"starting. source={OPENAPI_SOURCE} base_url={BASE_URL} "
        f"tools={len(TOOLS)} generator={GENERATOR_META}"
    )
    for message in _iter_messages():
        try:
            _handle_request(message)
        except Exception as exc:  # Defensive: never crash on single message.
            request_id = message.get("id") if isinstance(message, dict) else None
            _send_error(request_id, -32603, "Internal error", data=str(exc))


if __name__ == "__main__":
    main()
